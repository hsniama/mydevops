Azure repos - Credenciales
username:
henrysebastian.niama

password:
8ckA5T3RkIluaSO3vIR1dfOwJiEeDGBVFzjVTlxSP2z5CHbNSOcVJQQJ99BEACAAAAA9tF8vAAASAZDO2IUd


ACR
Login Server: devopsregistryhenry.azurecr.io
user: devopsregistryhenry
pass: 7fBnVsQvMIt97laH19htty5eB0EOgfBxUVrIxvo6+c+ACRDmv/44
pass2: 0cSLACqeI7LCGF4EVS3d2kQbMgpX2mUrAy1gtHrO29+ACRAyy5qf



--------------------------------------------------------------------------------------------------
Cada que se hace un cambio en el código:

git add . && git commit -m "Modificacion de README"
git push

Y poner clave de azure repos

-------------------------------------------------------------------------------------------------------------
Fase 1: 
uvicorn app.main:app --reload

ejecutar ambiente de python


curl -X GET https://devops-henry-2025.eastus.cloudapp.azure.com/generate-jwt

curl -X GET http://localhost:8000/generate-jwt

curl -X POST http://localhost:8000/DevOps \
  -H "X-Parse-REST-API-Key: 2f5ae96c-b558-4c7b-a590-a501ae1c3f6c" \
  -H "X-JWT-KWY: (endpoint obtenido en el primer endpoint get)" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Hola",
    "to": "Henry",
    "from": "Azure",
    "timeToLifeSec": 45
}'

---------------------------------------------------------------------------------------------------------------------------
Fase 2:

- Construir imagen:
docker build -t devops-microservice:local .


Nota: Si cambiamos el dockerfile hay que reconstruir la imagen y para eso primero hay que borrarla y volverla a crear.
Lo mismo con el contenedor.

Cambios que requieren reconstrucción de la imagen:

Modificas el Dockerfile
Cambias el requirements.txt
Cambias código fuente y usas COPY . . en el Dockerfile
Cambias la estructura de carpetas o rutas copiadas al contenedor
Quieres cambiar la imagen base (FROM python:...)
Actualizas dependencias (pip, apt, etc.)
Cambias la CMD o ENTRYPOINT

- Cosntruir contenedor:

docker rm -f devops-microservice
docker rmi devops-microservice:local

docker build -t devops-microservice:local .

Correr contenedor sin pasar las claves (recomendado):
docker run -d --name devops-microservice \
  --env-file .env \
  -p 8000:8000 \
  devops-microservice:local

Correr contenedor pasando las claves:
docker run --name devops-microservice \
  -p 8000:8000 \
  --env SECRET_KEY=clave_super_secreta_segura \
  --env API_KEY=2f5ae96c-b558-4c7b-a590-a501ae1c3f6c \
  devops-microservice:local

docker start -ai devops-microservice

Para entrar al contenedor:
docker exec -it devops-microservice /bin/sh


Acceder en el navegador: http://localhost:8000/generate-jwt 
y ejecutar el curl ...

------------------------------------------------------------------------------
Empaquetar tu imagen en un archivo .tar para compartirla (siempre y cuando pasamos las claves de .env directamente en 
el comando de docker para crear el contenedor):

docker save -o devops_microservice.tar devops-microservice:local

Ese .tar pasamos a la persona y el ejecutará esto:

docker load -i /ruta/donde/guardo/devops_microservice.tar

Una ves carga la imagen, el ya puede correr el contenedor si esta en Linux:

docker run --name devops-microservice \
  -p 8000:8000 \
  --env SECRET_KEY=clave_super_secreta_segura \
  --env API_KEY=2f5ae96c-b558-4c7b-a590-a501ae1c3f6c \
  devops-microservice:local

O si estan en windows en powershell o CMD con:

docker run --name devops-microservice ^
  -p 8000:8000 ^
  --env SECRET_KEY=clave_super_secreta_segura ^
  --env API_KEY=2f5ae96c-b558-4c7b-a590-a501ae1c3f6c ^
  devops-microservice:local

Y ya puede probar con: http://localhost:8000/generate-jwt 

------------------------------------------------------------------------------------

Fase 3:
docker build -t devops-microservice:v7 .
docker tag devops-microservice:v4 devopsregistryhenry.azurecr.io/devops-microservice:v7
docker push devopsregistryhenry.azurecr.io/devops-microservice:v7


curl -X POST https://devops-ms-henry-hhfsbjcubeh5ehg3.eastus-01.azurewebsites.net/DevOps \
  -H "X-Parse-REST-API-Key: 2f5ae96c-b558-4c7b-a590-a501ae1c3f6c" \
  -H "X-JWT-KWY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImV4cCI6MTc0MzU2Mjc5MX0.8m2XG-mU61bV2bohMOAMR2x-zdj0sDzd6QzXDjupEzU" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Hola",
    "to": "Henry",
    "from": "Azure",
    "timeToLifeSec": 45
}'

http://localhost:8000/generate-jwt 

Prender el contenedor con:
 docker run -d -p 8000:8000 --name devops-microservice devops-microservice:local

---
generar jwt
python -m app.utils.generate_jwt


---

--------------- AKS

Creación
az aks create \
  --resource-group devops \
  --name aks-devops-henry \
  --node-count 2 \
  --generate-ssh-keys

conectar terminal al cluster:
 az aks get-credentials --resource-group devops --name aks-devops-henry

Verificación de estar conectado.
kubectl get nodes

Verificar imagen en ACR
az acr repository list --name devopsregistryhenry --output table



tener IP publica
kubectl get service devops-service


get:
http://134.33.251.5/generate-jwt

post:

curl -X POST http://134.33.251.5/DevOps \
-H "Content-Type: application/json" \
-H "X-Parse-REST-API-Key: 2f5ae96c-b558-4c7b-a590-a501ae1c3f6c" \
-H "X-JWT-KWY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImV4cCI6MTc0MzkxNDcyNX0.grcmx9gUWXbx1qT4X7NKQrOci9x0IIgRT0IIY6UghiQ" \
-d '{
  "message": "This is a test",
  "to": "Juan Perez",
  "from": "Rita Asturia",
  "timeToLifeSec": 45
}'



******
Paso 1. Crear la Infra:
terraform init 
terraform plan
terraform apply -auto-approve


Paso 2.
az login
az account show
az account set --subscription "Nombre-de-tu-suscripcion"
Autenticarse en el ACR
az acr login --name devopsregistryhenry2025
az acr login -n devopsregistryhenry2025 --expose-token
Puedes validar con:
az acr list --resource-group DevOpsRG --query "[].{acrLoginServer:loginServer}" --output table


az acr credential show --name devopsregistryhenry2025
{
  "passwords": [
    {
      "name": "password",
      "value": "EQnnhodIP+fNsM8hriCJ46L6bs4phA5oocTq03ezMY+ACRCxGKq6"
    },
    {
      "name": "password2",
      "value": "SjbVM6omhmLSwmWAOBJSJJQ/ULvgjahtiHL37r7/E3+ACRCh7igi"
    }
  ],
  "username": "devopsregistryhenry2025"
}


docker login devopsregistryhenry2025.azurecr.io

Construir la imagen local Desde la raíz de tu proyecto:
docker build -t devops-microservice:latest .

Etiquetar la imagen con la URL del ACR
Necesitamos “taggear” la imagen local para empujarla al ACR:
docker tag devops-microservice:latest devopsregistryhenry2025.azurecr.io/devops-microservice:latest

Hacer push al ACR para subir la imagen:
docker push devopsregistryhenry2025.azurecr.io/devops-microservice:latest

Verificar en ACR
Puedes comprobar que está en tu registro:
az acr repository list --name devopsregistryhenry2025 --output table
az acr repository show-tags --name devopsregistryhenry2025 --repository devops-microservice:latest --output table




Pasp 3.
Asegurarnos de tener acceso al AKS

Primero verifica que puedes conectarte a tu cluster AKS:

az aks get-credentials --resource-group DevOpsRG --name devops-aks --overwrite-existing
kubectl get nodes
Si ves tus nodos, ya estás conectado.

Creamos el archivo:
k8s/secret.yaml

Y ejecutamos:
kubectl apply -f k8s/secret.yaml
kubectl get secret devops-secrets

Deployment del microservicio
Archivo:
k8s/deployment.yaml

aplicamos el deployment:
kubectl apply -f k8s/deployment.yaml
kubectl get pods

Service LoadBalancer
Archivo:
k8s/service.yaml
Aplica el service:
kubectl apply -f k8s/service.yaml
kubectl get svc

Verificar la IP y DNS
kubectl get svc devops-service

TLS Self-signed para HTTPS
Generamos certificado autofirmado (gratis, no personalizado):
Creo la carpeta certificado en la raiz y ejecuto el siguiente comando en bash:
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=microservice.local/O=DevOpsTest"


En el terminal de Powershell en la misma ruta del certificado, ejecuto:
kubectl create secret tls devops-tls --key tls.key --cert tls.crt
kubectl get secret devops-tls


Ingress con HTTPS
Archivo:
k8s/ingress.yaml
Notas importantes:

host puede ser cualquier subdominio barato de Azure Public IP.
path: /DevOps cumple el requerimiento del curl.
TLS apunta al secret devops-tls.

Creación IP con DNS

az network public-ip create --resource-group DevOpsRG --name devops-ingress-ip --sku Standard --allocation-method Static --dns-name devops-ingress-2025
Verificación
az network public-ip show --resource-group DevOpsRG --name devops-ingress-ip --query "{IP: ipAddress, DNS: dnsSettings.fqdn}" -o table
Resultado:
IP              DNS
--------------  ---------------------------------------------
52.224.127.197  devops-ingress-2025.eastus.cloudapp.azure.com

En tu service.yaml, añade la IP pública:

kubectl apply -f k8s/ingress.yaml
kubectl get ingress

en el k8s/ingress.yaml modificamos los hosts y host por el DNS que vemos arriba
y kubectl apply -f k8s/ingress.yaml
y comprobamos con kubectl get ingress


Para borrar:

kubectl delete deployment devops-microservice
kubectl delete service devops-service
kubectl delete ingress devops-ingress
kubectl delete secret devops-secrets
kubectl delete secret devops-tls-secret
az network public-ip delete --resource-group DevOpsRG --name devops-ingress-ip


kubectl apply -f k8s/
kubectl delete -f k8s/
terraform destroy -auto-approve
